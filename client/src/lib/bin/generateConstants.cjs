#!/usr/bin/env node

const fs = require("fs");
const path = require("path");

function getFolderFilesRecursively(folder, extension = null) {
  let files = [];
  fs.readdirSync(folder).forEach(File => {
    const absPath = path.join(folder, File);
    if (fs.statSync(absPath).isDirectory()) {
      files = files.concat(getFolderFilesRecursively(absPath));
    } else if (!extension || absPath.endsWith(extension)) {
      files.push(absPath);
    }
  });
  return files;
}

function cleanLine(line) {
  let result = '';
  const commentParts = line.split('//');
  result = commentParts[0].trim();
  return result;
}

function getModsConstantsFromCairoFile(filePath) {
  const mods = {};
  const contents = fs.readFileSync(filePath, "utf8");
  const lines = contents.split('\n');
  // parse contents
  let is_test = false;
  let current_mod = null;
  lines.forEach((line) => {
    if (!current_mod) {
      if (line == '#[cfg(test)]') {
        is_test = true;
      } else if (line.startsWith('mod ') && line.endsWith(' {')) {
        current_mod = line.slice(4, -2);
        // console.log(`MOD!!`, current_mod, line)
        if (!is_test) {
          mods[current_mod] = {
            filePath,
            constants: [],
          }
        }
      }
    } else {
      const l = cleanLine(line);
      if (l) {
        if (l == '}') {
          current_mod = null;
          is_test = false;
        } else if (!is_test && l.startsWith('const ')) {
          // console.log(l)
          mods[current_mod].constants.push(l)
        }
      }
    }
  })
  // console.log(mods)
  return mods;
}

const cairoToTypescriptType = {
  bool: "boolean",
  u8: "number",
  u16: "number",
  u32: "number",
  u64: "BigNumberish",
  usize: "number",
  u128: "BigNumberish",
  u256: "BigNumberish",
  felt252: "BigNumberish",
  contractaddress: "BigNumberish",
  enum: "string",
};

function parseMods(mods) {
  let fileContents = '';
  fileContents += `/* Autogenerated file. Do not edit manually. */\n`;
  fileContents += `import { BigNumberish } from 'starknet';\n`;

  // example lines:
  // "const LORDS: felt252 = 'Lords';"
  // "const PISTOLS_KILL_AT_STEP_1: u8 = 5;""
  // "const DuelistRegisteredEvent: felt252 = 0x148c3db21a55576bc012023dc4d3b5bd570c519de855849eac52b1c5d6c9e85;"
  // "const ETH_TO_WEI: u256 = 1_000_000_000_000_000_000;"

  Object.keys(mods).forEach((key) => {
    let fileName = mods[key].filePath;
    let modTypeName = `mod_${key}_Type`;
    let modType = `type ${modTypeName} = {\n`;
    let modValues = `export const ${key}: ${modTypeName} = {\n`;
    mods[key].constants.forEach((line) => {
      // remove 'const ' and ';'
      const l = line.slice('const '.length, -1);
      const [_decl, _value] = l.split('=');
      const [_name, _type] = _decl.split(':');
      const name = _name.trim();
      const type = _type.trim();
      const value = _value.trim();
      const ts_type = (type == 'felt252' && (value.startsWith('"') || value.startsWith("'"))) ? 'string' : cairoToTypescriptType[type];
      const ts_value = (ts_type == 'BigNumberish') ? `'${value}'` : value;
      // if (ts_type == 'BigNumberish' || ts_type == 'number') ts_value = ts_value.replaceAll('_', '');
      if (!ts_type) {
        console.error(`ERROR: Invalid type [${type}] from:`, line);
        process.exit(1);
      }
      modType += `  ${name}: ${ts_type}, // cairo: ${type}\n`;
      modValues += `  ${name}: ${ts_value},\n`;
    })
    modType += `};\n`;
    modValues += `};\n`;
    // write contents
    fileContents += '\n';
    fileContents += `// from: ${fileName}\n`;
    fileContents += modType;
    fileContents += modValues;
  })

  return fileContents;
}

//----------------------
// Execution
//

// Check for the required arguments
if (process.argv.length !== 4) {
  console.log(
    "Usage: npm run create-constants <SRC_PATH> <OUTPUT_PATH>",
    "Usage: npm run create-constants --game=<GAME_SLUG> --profile=<PROFILE>"
  );
  process.exit(1);
}

// Extract paths from command-line arguments
// const srcPath = path.resolve(process.argv[2]);
const srcPath = (process.argv[2]); // keep relative
const jsFilePath = path.resolve(process.argv[3]);

// console.log(`process.argv`, process.argv)
// console.log(`srcPath [${process.argv[2]}] > [${srcPath}]`)
// console.log(`jsFilePath [${process.argv[3]}] > [${jsFilePath}]`)

let cairoFiles = getFolderFilesRecursively(srcPath, '.cairo');

let mods = cairoFiles.reduce((acc, filePath) => {
  const mods = getModsConstantsFromCairoFile(filePath)
  Object.keys(mods).forEach((key) => {
    if (mods[key].constants.length > 0) {
      if (acc[key]) {
        console.error(`ERROR: Duplicated mod [${key}]`)
        process.exit(1);
      }
      acc[key] = mods[key];
    }
  })
  return acc;
}, [])
// console.log(mods)

const fileContents = parseMods(mods)
// console.log(fileContents)

fs.writeFile(jsFilePath, fileContents, (err) => {
  if (err) {
    console.error("ERROR: error writing file:", err);
  } else {
    console.log("Constants file generated successfully:", jsFilePath);
  }
});
