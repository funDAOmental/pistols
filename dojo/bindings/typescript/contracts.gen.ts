// Generated by dojo-bindgen on Thu, 11 Apr 2024 21:01:56 +0000. Do not modify this file manually.
import { Account } from "starknet";
import { DojoProvider } from "@dojoengine/core";
import * as models from "./models.gen";

export type IWorld = Awaited<ReturnType<typeof setupWorld>>;

export async function setupWorld(provider: DojoProvider) {
    // System definitions for `pistols::systems::actions::actions` contract
    function actions() {
        const contract_name = "actions";

        
        // Call the `register_duelist` system with the specified Account and calldata
        const registerDuelist = async (props: { account: Account, name: BigInt, profile_pic: Number }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "register_duelist",
                    [props.name,
                props.profile_pic]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `create_challenge` system with the specified Account and calldata
        const createChallenge = async (props: { account: Account, challenged: BigInt, message: BigInt, wager_coin: Number, wager_value: models.U256, expire_seconds: Number }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "create_challenge",
                    [props.challenged,
                props.message,
                props.wager_coin,
                props.wager_value.low,
                    props.wager_value.high,
                props.expire_seconds]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `reply_challenge` system with the specified Account and calldata
        const replyChallenge = async (props: { account: Account, duel_id: BigInt, accepted: Boolean }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "reply_challenge",
                    [props.duel_id,
                props.accepted]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `commit_action` system with the specified Account and calldata
        const commitAction = async (props: { account: Account, duel_id: BigInt, round_number: Number, hash: Number }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "commit_action",
                    [props.duel_id,
                props.round_number,
                props.hash]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `reveal_action` system with the specified Account and calldata
        const revealAction = async (props: { account: Account, duel_id: BigInt, round_number: Number, salt: Number, action_slot1: Number, action_slot2: Number }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "reveal_action",
                    [props.duel_id,
                props.round_number,
                props.salt,
                props.action_slot1,
                props.action_slot2]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `get_pact` system with the specified Account and calldata
        const getPact = async (props: { account: Account, duelist_a: BigInt, duelist_b: BigInt }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "get_pact",
                    [props.duelist_a,
                props.duelist_b]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `has_pact` system with the specified Account and calldata
        const hasPact = async (props: { account: Account, duelist_a: BigInt, duelist_b: BigInt }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "has_pact",
                    [props.duelist_a,
                props.duelist_b]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `calc_fee` system with the specified Account and calldata
        const calcFee = async (props: { account: Account, wager_coin: Number, wager_value: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "calc_fee",
                    [props.wager_coin,
                props.wager_value.low,
                    props.wager_value.high]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `calc_hit_bonus` system with the specified Account and calldata
        const calcHitBonus = async (props: { account: Account, duelist_address: BigInt }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "calc_hit_bonus",
                    [props.duelist_address]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `calc_hit_penalty` system with the specified Account and calldata
        const calcHitPenalty = async (props: { account: Account, health: Number }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "calc_hit_penalty",
                    [props.health]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `calc_hit_chances` system with the specified Account and calldata
        const calcHitChances = async (props: { account: Account, duelist_address: BigInt, duel_id: BigInt, round_number: Number, action: Number }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "calc_hit_chances",
                    [props.duelist_address,
                props.duel_id,
                props.round_number,
                props.action]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `calc_crit_chances` system with the specified Account and calldata
        const calcCritChances = async (props: { account: Account, duelist_address: BigInt, duel_id: BigInt, round_number: Number, action: Number }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "calc_crit_chances",
                    [props.duelist_address,
                props.duel_id,
                props.round_number,
                props.action]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `calc_glance_chances` system with the specified Account and calldata
        const calcGlanceChances = async (props: { account: Account, duelist_address: BigInt, duel_id: BigInt, round_number: Number, action: Number }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "calc_glance_chances",
                    [props.duelist_address,
                props.duel_id,
                props.round_number,
                props.action]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `calc_honour_for_action` system with the specified Account and calldata
        const calcHonourForAction = async (props: { account: Account, duelist_address: BigInt, action: Number }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "calc_honour_for_action",
                    [props.duelist_address,
                props.action]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `get_valid_packed_actions` system with the specified Account and calldata
        const getValidPackedActions = async (props: { account: Account, round_number: Number }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "get_valid_packed_actions",
                    [props.round_number]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `pack_action_slots` system with the specified Account and calldata
        const packActionSlots = async (props: { account: Account, slot1: Number, slot2: Number }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "pack_action_slots",
                    [props.slot1,
                props.slot2]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `unpack_action_slots` system with the specified Account and calldata
        const unpackActionSlots = async (props: { account: Account, packed: Number }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "unpack_action_slots",
                    [props.packed]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `dojo_resource` system with the specified Account and calldata
        const dojoResource = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "dojo_resource",
                    []
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

        return {
            registerDuelist, createChallenge, replyChallenge, commitAction, revealAction, getPact, hasPact, calcFee, calcHitBonus, calcHitPenalty, calcHitChances, calcCritChances, calcGlanceChances, calcHonourForAction, getValidPackedActions, packActionSlots, unpackActionSlots, dojoResource
        };
    }

    // System definitions for `pistols::systems::admin::admin` contract
    function admin() {
        const contract_name = "admin";

        
        // Call the `dojo_resource` system with the specified Account and calldata
        const dojoResource = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "dojo_resource",
                    []
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `initialize` system with the specified Account and calldata
        const initialize = async (props: { account: Account, owner_address: BigInt, treasury_address: BigInt, lords_address: BigInt }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "initialize",
                    [props.owner_address,
                props.treasury_address,
                props.lords_address]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `is_initialized` system with the specified Account and calldata
        const isInitialized = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "is_initialized",
                    []
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `set_owner` system with the specified Account and calldata
        const setOwner = async (props: { account: Account, owner_address: BigInt }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "set_owner",
                    [props.owner_address]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `set_treasury` system with the specified Account and calldata
        const setTreasury = async (props: { account: Account, treasury_address: BigInt }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "set_treasury",
                    [props.treasury_address]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `set_paused` system with the specified Account and calldata
        const setPaused = async (props: { account: Account, paused: Boolean }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "set_paused",
                    [props.paused]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `set_coin` system with the specified Account and calldata
        const setCoin = async (props: { account: Account, coin_key: Number, contract_address: BigInt, description: BigInt, fee_min: models.U256, fee_pct: Number, enabled: Boolean }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "set_coin",
                    [props.coin_key,
                props.contract_address,
                props.description,
                props.fee_min.low,
                    props.fee_min.high,
                props.fee_pct,
                props.enabled]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `enable_coin` system with the specified Account and calldata
        const enableCoin = async (props: { account: Account, coin_key: Number, enabled: Boolean }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "enable_coin",
                    [props.coin_key,
                props.enabled]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `get_config` system with the specified Account and calldata
        const getConfig = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "get_config",
                    []
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `get_coin` system with the specified Account and calldata
        const getCoin = async (props: { account: Account, coin_key: Number }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "get_coin",
                    [props.coin_key]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

        return {
            dojoResource, initialize, isInitialized, setOwner, setTreasury, setPaused, setCoin, enableCoin, getConfig, getCoin
        };
    }

    // System definitions for `pistols::mocks::lords_mock::lords_mock` contract
    function lords_mock() {
        const contract_name = "lords_mock";

        
        // Call the `balance_of` system with the specified Account and calldata
        const balanceOf = async (props: { account: Account, account: BigInt }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "balance_of",
                    [props.account]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `transfer` system with the specified Account and calldata
        const transfer = async (props: { account: Account, recipient: BigInt, amount: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "transfer",
                    [props.recipient,
                props.amount.low,
                    props.amount.high]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `transfer_from` system with the specified Account and calldata
        const transferFrom = async (props: { account: Account, sender: BigInt, recipient: BigInt, amount: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "transfer_from",
                    [props.sender,
                props.recipient,
                props.amount.low,
                    props.amount.high]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `name` system with the specified Account and calldata
        const name = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "name",
                    []
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `symbol` system with the specified Account and calldata
        const symbol = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "symbol",
                    []
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `decimals` system with the specified Account and calldata
        const decimals = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "decimals",
                    []
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `allowance` system with the specified Account and calldata
        const allowance = async (props: { account: Account, owner: BigInt, spender: BigInt }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "allowance",
                    [props.owner,
                props.spender]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `approve` system with the specified Account and calldata
        const approve = async (props: { account: Account, spender: BigInt, amount: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "approve",
                    [props.spender,
                props.amount.low,
                    props.amount.high]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `faucet` system with the specified Account and calldata
        const faucet = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "faucet",
                    []
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `balanceOf` system with the specified Account and calldata
        const balanceOf = async (props: { account: Account, account: BigInt }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "balanceOf",
                    [props.account]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `transferFrom` system with the specified Account and calldata
        const transferFrom = async (props: { account: Account, sender: BigInt, recipient: BigInt, amount: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "transferFrom",
                    [props.sender,
                props.recipient,
                props.amount.low,
                    props.amount.high]
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `initializer` system with the specified Account and calldata
        const initializer = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "initializer",
                    []
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `is_initialized` system with the specified Account and calldata
        const isInitialized = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "is_initialized",
                    []
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `total_supply` system with the specified Account and calldata
        const totalSupply = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "total_supply",
                    []
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `dojo_resource` system with the specified Account and calldata
        const dojoResource = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "dojo_resource",
                    []
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `totalSupply` system with the specified Account and calldata
        const totalSupply = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "totalSupply",
                    []
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

        return {
            balanceOf, transfer, transferFrom, name, symbol, decimals, allowance, approve, faucet, balanceOf, transferFrom, initializer, isInitialized, totalSupply, dojoResource, totalSupply
        };
    }

    return {
        actions: actions(),
        admin: admin(),
        lords_mock: lords_mock()
    };
}
