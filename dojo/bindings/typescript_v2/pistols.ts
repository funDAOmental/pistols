// Generated by dojo-bindgen on Wed, 5 Jun 2024 21:28:24 +0000. Do not modify this file manually.
import { Account } from "starknet";
import {
    Clause,
    Client,
    ModelClause,
    createClient,
    valueToToriiValueAndOperator,
} from "@dojoengine/torii-client";
import {
    LOCAL_KATANA,
    LOCAL_RELAY,
    LOCAL_TORII,
    createManifestFromJson,
} from "@dojoengine/core";

// Type definition for `core::integer::u256` struct
export interface U256 {
    low: bigint;
    high: bigint;
}

// Type definition for `pistols::models::table::TTable` struct
export interface TTable {
    table_id: string;
    description: string;
    contract_address: string;
    wager_min: U256;
    fee_min: U256;
    fee_pct: number;
    is_open: boolean;
}


// Type definition for `pistols::models::models::Pact` struct
export interface Pact {
    pair: bigint;
    duel_id: bigint;
}


// Type definition for `pistols::models::models::Score` struct
export interface Score {
    honour: number;
    level_villain: number;
    level_trickster: number;
    level_lord: number;
    total_duels: number;
    total_wins: number;
    total_losses: number;
    total_draws: number;
    total_honour: number;
}

// Type definition for `pistols::models::models::Duelist` struct
export interface Duelist {
    address: string;
    name: string;
    profile_pic: number;
    score: Score;
    timestamp: bigint;
}


// Type definition for `core::integer::u256` struct
export interface U256 {
    low: bigint;
    high: bigint;
}

// Type definition for `token::components::token::erc20::erc20_metadata::ERC20MetadataModel` struct
export interface ERC20MetadataModel {
    token: string;
    name: string;
    symbol: string;
    decimals: number;
    total_supply: U256;
}


// Type definition for `pistols::models::config::Config` struct
export interface Config {
    key: number;
    initialized: boolean;
    owner_address: string;
    treasury_address: string;
    paused: boolean;
}


// Type definition for `pistols::models::models::Chances` struct
export interface Chances {
    key: string;
    crit_chances: number;
    crit_bonus: number;
    hit_chances: number;
    hit_bonus: number;
    lethal_chances: number;
    lethal_bonus: number;
}


// Type definition for `pistols::models::models::Challenge` struct
export interface Challenge {
    duel_id: bigint;
    duelist_a: string;
    duelist_b: string;
    message: string;
    table_id: string;
    state: number;
    round_number: number;
    winner: number;
    timestamp_start: bigint;
    timestamp_end: bigint;
}


// Type definition for `core::integer::u256` struct
export interface U256 {
    low: bigint;
    high: bigint;
}

// Type definition for `pistols::models::models::Score` struct
export interface Score {
    honour: number;
    level_villain: number;
    level_trickster: number;
    level_lord: number;
    total_duels: number;
    total_wins: number;
    total_losses: number;
    total_draws: number;
    total_honour: number;
}

// Type definition for `pistols::models::models::Scoreboard` struct
export interface Scoreboard {
    address: string;
    table_id: string;
    score: Score;
    wager_won: U256;
    wager_lost: U256;
}


// Type definition for `token::components::security::initializable::InitializableModel` struct
export interface InitializableModel {
    token: string;
    initialized: boolean;
}


// Type definition for `core::integer::u256` struct
export interface U256 {
    low: bigint;
    high: bigint;
}

// Type definition for `pistols::models::models::Wager` struct
export interface Wager {
    duel_id: bigint;
    value: U256;
    fee: U256;
}


// Type definition for `core::integer::u256` struct
export interface U256 {
    low: bigint;
    high: bigint;
}

// Type definition for `token::components::token::erc20::erc20_allowance::ERC20AllowanceModel` struct
export interface ERC20AllowanceModel {
    token: string;
    owner: string;
    spender: string;
    amount: U256;
}


// Type definition for `core::integer::u256` struct
export interface U256 {
    low: bigint;
    high: bigint;
}

// Type definition for `token::components::token::erc20::erc20_balance::ERC20BalanceModel` struct
export interface ERC20BalanceModel {
    token: string;
    account: string;
    amount: U256;
}


// Type definition for `pistols::models::models::Shot` struct
export interface Shot {
    hash: bigint;
    salt: bigint;
    action: number;
    chance_crit: number;
    chance_hit: number;
    dice_crit: number;
    dice_hit: number;
    damage: number;
    block: number;
    win: number;
    wager: number;
    health: number;
    honour: number;
}

// Type definition for `pistols::models::models::Round` struct
export interface Round {
    duel_id: bigint;
    round_number: number;
    state: number;
    shot_a: Shot;
    shot_b: Shot;
}


// Type definition for `pistols::models::models::Score` struct
export interface Score {
    honour: number;
    level_villain: number;
    level_trickster: number;
    level_lord: number;
    total_duels: number;
    total_wins: number;
    total_losses: number;
    total_draws: number;
    total_honour: number;
}

// Type definition for `pistols::models::models::Snapshot` struct
export interface Snapshot {
    duel_id: bigint;
    score_a: Score;
    score_b: Score;
}


class BaseCalls {
    contractAddress: string;
    account?: Account;

    constructor(contractAddress: string, account?: Account) {
        this.account = account;
        this.contractAddress = contractAddress;
    }

    async execute(entrypoint: string, calldata: any[] = []): Promise<void> {
        if (!this.account) {
            throw new Error("No account set to interact with dojo_starter");
        }

        await this.account.execute(
            {
                contractAddress: this.contractAddress,
                entrypoint,
                calldata,
            },
            undefined,
            {
                maxFee: 0,
            }
        );
    }
}

class AdminCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }
    
    async dojoResource(): Promise<void> {
        try {
            await this.execute("dojo_resource", [])
        } catch (error) {
            console.error("Error executing dojoResource:", error);
            throw error;
        }
    }

    async initialize(owner_address: string, treasury_address: string, lords_address: string): Promise<void> {
        try {
            await this.execute("initialize", [owner_address,
                treasury_address,
                lords_address])
        } catch (error) {
            console.error("Error executing initialize:", error);
            throw error;
        }
    }

    async isInitialized(): Promise<void> {
        try {
            await this.execute("is_initialized", [])
        } catch (error) {
            console.error("Error executing isInitialized:", error);
            throw error;
        }
    }

    async setOwner(owner_address: string): Promise<void> {
        try {
            await this.execute("set_owner", [owner_address])
        } catch (error) {
            console.error("Error executing setOwner:", error);
            throw error;
        }
    }

    async setTreasury(treasury_address: string): Promise<void> {
        try {
            await this.execute("set_treasury", [treasury_address])
        } catch (error) {
            console.error("Error executing setTreasury:", error);
            throw error;
        }
    }

    async setPaused(paused: boolean): Promise<void> {
        try {
            await this.execute("set_paused", [paused])
        } catch (error) {
            console.error("Error executing setPaused:", error);
            throw error;
        }
    }

    async setTable(table_id: string, contract_address: string, description: string, fee_min: U256, fee_pct: number, enabled: boolean): Promise<void> {
        try {
            await this.execute("set_table", [table_id,
                contract_address,
                description,
                props.fee_min.low,
                    props.fee_min.high,
                fee_pct,
                enabled])
        } catch (error) {
            console.error("Error executing setTable:", error);
            throw error;
        }
    }

    async enableTable(table_id: string, enabled: boolean): Promise<void> {
        try {
            await this.execute("enable_table", [table_id,
                enabled])
        } catch (error) {
            console.error("Error executing enableTable:", error);
            throw error;
        }
    }

    async getConfig(): Promise<void> {
        try {
            await this.execute("get_config", [])
        } catch (error) {
            console.error("Error executing getConfig:", error);
            throw error;
        }
    }

    async getTable(table_id: string): Promise<void> {
        try {
            await this.execute("get_table", [table_id])
        } catch (error) {
            console.error("Error executing getTable:", error);
            throw error;
        }
    }
}
class LordsMockCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }
    
    async name(): Promise<void> {
        try {
            await this.execute("name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async symbol(): Promise<void> {
        try {
            await this.execute("symbol", [])
        } catch (error) {
            console.error("Error executing symbol:", error);
            throw error;
        }
    }

    async decimals(): Promise<void> {
        try {
            await this.execute("decimals", [])
        } catch (error) {
            console.error("Error executing decimals:", error);
            throw error;
        }
    }

    async faucet(): Promise<void> {
        try {
            await this.execute("faucet", [])
        } catch (error) {
            console.error("Error executing faucet:", error);
            throw error;
        }
    }

    async allowance(owner: string, spender: string): Promise<void> {
        try {
            await this.execute("allowance", [owner,
                spender])
        } catch (error) {
            console.error("Error executing allowance:", error);
            throw error;
        }
    }

    async approve(spender: string, amount: U256): Promise<void> {
        try {
            await this.execute("approve", [spender,
                props.amount.low,
                    props.amount.high])
        } catch (error) {
            console.error("Error executing approve:", error);
            throw error;
        }
    }

    async totalSupply(): Promise<void> {
        try {
            await this.execute("total_supply", [])
        } catch (error) {
            console.error("Error executing totalSupply:", error);
            throw error;
        }
    }

    async dojoResource(): Promise<void> {
        try {
            await this.execute("dojo_resource", [])
        } catch (error) {
            console.error("Error executing dojoResource:", error);
            throw error;
        }
    }

    async initializer(): Promise<void> {
        try {
            await this.execute("initializer", [])
        } catch (error) {
            console.error("Error executing initializer:", error);
            throw error;
        }
    }

    async isInitialized(): Promise<void> {
        try {
            await this.execute("is_initialized", [])
        } catch (error) {
            console.error("Error executing isInitialized:", error);
            throw error;
        }
    }

    async totalSupply(): Promise<void> {
        try {
            await this.execute("totalSupply", [])
        } catch (error) {
            console.error("Error executing totalSupply:", error);
            throw error;
        }
    }

    async balanceOf(account: string): Promise<void> {
        try {
            await this.execute("balanceOf", [account])
        } catch (error) {
            console.error("Error executing balanceOf:", error);
            throw error;
        }
    }

    async transferFrom(sender: string, recipient: string, amount: U256): Promise<void> {
        try {
            await this.execute("transferFrom", [sender,
                recipient,
                props.amount.low,
                    props.amount.high])
        } catch (error) {
            console.error("Error executing transferFrom:", error);
            throw error;
        }
    }

    async balanceOf(account: string): Promise<void> {
        try {
            await this.execute("balance_of", [account])
        } catch (error) {
            console.error("Error executing balanceOf:", error);
            throw error;
        }
    }

    async transfer(recipient: string, amount: U256): Promise<void> {
        try {
            await this.execute("transfer", [recipient,
                props.amount.low,
                    props.amount.high])
        } catch (error) {
            console.error("Error executing transfer:", error);
            throw error;
        }
    }

    async transferFrom(sender: string, recipient: string, amount: U256): Promise<void> {
        try {
            await this.execute("transfer_from", [sender,
                recipient,
                props.amount.low,
                    props.amount.high])
        } catch (error) {
            console.error("Error executing transferFrom:", error);
            throw error;
        }
    }
}
class ActionsCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }
    
    async registerDuelist(name: string, profile_pic: number): Promise<void> {
        try {
            await this.execute("register_duelist", [name,
                profile_pic])
        } catch (error) {
            console.error("Error executing registerDuelist:", error);
            throw error;
        }
    }

    async createChallenge(challenged: string, message: string, table_id: string, wager_value: U256, expire_seconds: bigint): Promise<void> {
        try {
            await this.execute("create_challenge", [challenged,
                message,
                table_id,
                props.wager_value.low,
                    props.wager_value.high,
                expire_seconds])
        } catch (error) {
            console.error("Error executing createChallenge:", error);
            throw error;
        }
    }

    async replyChallenge(duel_id: bigint, accepted: boolean): Promise<void> {
        try {
            await this.execute("reply_challenge", [duel_id,
                accepted])
        } catch (error) {
            console.error("Error executing replyChallenge:", error);
            throw error;
        }
    }

    async commitAction(duel_id: bigint, round_number: number, hash: bigint): Promise<void> {
        try {
            await this.execute("commit_action", [duel_id,
                round_number,
                hash])
        } catch (error) {
            console.error("Error executing commitAction:", error);
            throw error;
        }
    }

    async revealAction(duel_id: bigint, round_number: number, salt: bigint, action_slot1: number, action_slot2: number): Promise<void> {
        try {
            await this.execute("reveal_action", [duel_id,
                round_number,
                salt,
                action_slot1,
                action_slot2])
        } catch (error) {
            console.error("Error executing revealAction:", error);
            throw error;
        }
    }

    async getPact(duelist_a: string, duelist_b: string): Promise<void> {
        try {
            await this.execute("get_pact", [duelist_a,
                duelist_b])
        } catch (error) {
            console.error("Error executing getPact:", error);
            throw error;
        }
    }

    async hasPact(duelist_a: string, duelist_b: string): Promise<void> {
        try {
            await this.execute("has_pact", [duelist_a,
                duelist_b])
        } catch (error) {
            console.error("Error executing hasPact:", error);
            throw error;
        }
    }

    async calcFee(table_id: string, wager_value: U256): Promise<void> {
        try {
            await this.execute("calc_fee", [table_id,
                props.wager_value.low,
                    props.wager_value.high])
        } catch (error) {
            console.error("Error executing calcFee:", error);
            throw error;
        }
    }

    async simulateHonourForAction(duelist_address: string, action: number): Promise<void> {
        try {
            await this.execute("simulate_honour_for_action", [duelist_address,
                action])
        } catch (error) {
            console.error("Error executing simulateHonourForAction:", error);
            throw error;
        }
    }

    async simulateChances(duelist_address: string, duel_id: bigint, round_number: number, action: number): Promise<void> {
        try {
            await this.execute("simulate_chances", [duelist_address,
                duel_id,
                round_number,
                action])
        } catch (error) {
            console.error("Error executing simulateChances:", error);
            throw error;
        }
    }

    async getValidPackedActions(round_number: number): Promise<void> {
        try {
            await this.execute("get_valid_packed_actions", [round_number])
        } catch (error) {
            console.error("Error executing getValidPackedActions:", error);
            throw error;
        }
    }

    async packActionSlots(slot1: number, slot2: number): Promise<void> {
        try {
            await this.execute("pack_action_slots", [slot1,
                slot2])
        } catch (error) {
            console.error("Error executing packActionSlots:", error);
            throw error;
        }
    }

    async unpackActionSlots(packed: number): Promise<void> {
        try {
            await this.execute("unpack_action_slots", [packed])
        } catch (error) {
            console.error("Error executing unpackActionSlots:", error);
            throw error;
        }
    }

    async dojoResource(): Promise<void> {
        try {
            await this.execute("dojo_resource", [])
        } catch (error) {
            console.error("Error executing dojoResource:", error);
            throw error;
        }
    }
}

type Query = Partial<{
    TTable: ModelClause<TTable>;
    Pact: ModelClause<Pact>;
    Duelist: ModelClause<Duelist>;
    Erc20MetadataModel: ModelClause<Erc20MetadataModel>;
    Config: ModelClause<Config>;
    Chances: ModelClause<Chances>;
    Challenge: ModelClause<Challenge>;
    Scoreboard: ModelClause<Scoreboard>;
    InitializableModel: ModelClause<InitializableModel>;
    Wager: ModelClause<Wager>;
    Erc20AllowanceModel: ModelClause<Erc20AllowanceModel>;
    Erc20BalanceModel: ModelClause<Erc20BalanceModel>;
    Round: ModelClause<Round>;
    Snapshot: ModelClause<Snapshot>;
}>;

type ResultMapping = {
    TTable: TTable;
    Pact: Pact;
    Duelist: Duelist;
    Erc20MetadataModel: Erc20MetadataModel;
    Config: Config;
    Chances: Chances;
    Challenge: Challenge;
    Scoreboard: Scoreboard;
    InitializableModel: InitializableModel;
    Wager: Wager;
    Erc20AllowanceModel: Erc20AllowanceModel;
    Erc20BalanceModel: Erc20BalanceModel;
    Round: Round;
    Snapshot: Snapshot;
};

type QueryResult<T extends Query> = {
    [K in keyof T]: K extends keyof ResultMapping ? ResultMapping[K] : never;
};

// Only supports a single model for now, since torii doesn't support multiple models
// And inside that single model, there's only support for a single query.
function convertQueryToToriiClause(query: Query): Clause | undefined {
    const [model, clause] = Object.entries(query)[0];

    if (Object.keys(clause).length === 0) {
        return undefined;
    }

    const clauses: Clause[] = Object.entries(clause).map(([key, value]) => {
        return {
            Member: {
                model,
                member: key,
                ...valueToToriiValueAndOperator(value),
            },
        } satisfies Clause;
    });

    return clauses[0];
}
type GeneralParams = {
    toriiUrl?: string;
    relayUrl?: string;
    account?: Account;
};

type InitialParams = GeneralParams &
    (
        | {
                rpcUrl?: string;
                worldAddress: string;
                adminAddress: string;
    lordsMockAddress: string;
    actionsAddress: string;
            }
        | {
                manifest: any;
            }
    );

export class Pistols {
    rpcUrl: string;
    toriiUrl: string;
    toriiPromise: Promise<Client>;
    relayUrl: string;
    worldAddress: string;
    private _account?: Account;
    admin: AdminCalls;
    adminAddress: string;
    lordsMock: LordsMockCalls;
    lordsMockAddress: string;
    actions: ActionsCalls;
    actionsAddress: string;

    constructor(params: InitialParams) {
        if ("manifest" in params) {
            const config = createManifestFromJson(params.manifest);
            this.rpcUrl = config.world.metadata.rpc_url;
            this.worldAddress = config.world.address;

            const adminAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::admin::admin"
            )?.address;

            if (!adminAddress) {
                throw new Error("No admin contract found in the manifest");
            }

            this.adminAddress = adminAddress;
    const lordsMockAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::lordsMock::lordsMock"
            )?.address;

            if (!lordsMockAddress) {
                throw new Error("No lordsMock contract found in the manifest");
            }

            this.lordsMockAddress = lordsMockAddress;
    const actionsAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::actions::actions"
            )?.address;

            if (!actionsAddress) {
                throw new Error("No actions contract found in the manifest");
            }

            this.actionsAddress = actionsAddress;
        } else {
            this.rpcUrl = params.rpcUrl || LOCAL_KATANA;
            this.worldAddress = params.worldAddress;
            this.adminAddress = params.adminAddress;
    this.lordsMockAddress = params.lordsMockAddress;
    this.actionsAddress = params.actionsAddress;
        }
        this.toriiUrl = params.toriiUrl || LOCAL_TORII;
        this.relayUrl = params.relayUrl || LOCAL_RELAY;
        this._account = params.account;
        this.admin = new AdminCalls(this.adminAddress, this._account);
    this.lordsMock = new LordsMockCalls(this.lordsMockAddress, this._account);
    this.actions = new ActionsCalls(this.actionsAddress, this._account);

        this.toriiPromise = createClient([], {
            rpcUrl: this.rpcUrl,
            toriiUrl: this.toriiUrl,
            worldAddress: this.worldAddress,
            relayUrl: this.relayUrl,
        });
    }

    get account(): Account | undefined {
        return this._account;
    }

    set account(account: Account) {
        this._account = account;
        this.admin = new AdminCalls(this.adminAddress, this._account);
    this.lordsMock = new LordsMockCalls(this.lordsMockAddress, this._account);
    this.actions = new ActionsCalls(this.actionsAddress, this._account);
    }

    async query<T extends Query>(query: T, limit = 10, offset = 0) {
        const torii = await this.toriiPromise;

        return {
            torii,
            findEntities: async () => this.findEntities(query, limit, offset),
        };
    }

    async findEntities<T extends Query>(query: T, limit = 10, offset = 0) {
        const torii = await this.toriiPromise;

        const clause = convertQueryToToriiClause(query);

        const toriiResult = await torii.getEntities({
            limit,
            offset,
            clause,
        });

        return toriiResult as Record<string, QueryResult<T>>;
    }

    async findEntity<T extends Query>(query: T) {
        const result = await this.findEntities(query, 1);

        if (Object.values(result).length === 0) {
            return undefined;
        }

        return Object.values(result)[0] as QueryResult<T>;
    }
}